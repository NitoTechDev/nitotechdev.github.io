<!DOCTYPE html>
<html>
    <title>NitoTech | Creating an External Cheat Overlay with Direct3D 9</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../index.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,400;1,400&display=swap" rel="stylesheet">
    <script src="../../blog.js"></script>
    <body>
        <div class="header poppins-regular">
            <h1>NitoTech</h1>
            <p>Game Vulnerability Researcher | Anti-Cheat Enthusiast</p>
        </div>

        <div class="navbar">
            <a href="../../index.html">Home</a>
            <a href="../../posts.html">Posts</a>
            <a href="../../contact.html" class="right">Contact</a>
        </div>

        <div class="row">
            <div class="blog-side">
                <h2>Check out my <br>other Posts!</h2>
                <h3>My Favorite Projects</h3>
                <p>Here are some of my favorite projects I've worked on</p>
                <div class="mini-posts"><a href="#HackingNioh">Nioh Hack<br>(Under Revisions)</a></div><br>
                <div class="mini-posts"><a href="#SMAT">Static Malware Analysis Tool<br>(Blog in Development)</a></div><br>
                <div class="mini-posts"><a href="./posts/how-do-cheat-overlays-work/">Direct3D 9 Overlay Concepts</a></div>
            </div>
            <div class="blog-main">
                <h1>Creating an External Cheat Overlay with Direct3D 9</h1>
                <h5>Sep 21, 2025 | Direct3D 9 Overlay Code Writeup</h5>
                <hr>
                <h2>Introduction</h2>
                    <p>
                        Have you ever wanted to create an overlay for your cheats and wern't sure where to start? Below we will explore how to code an overlay that will work for nearly any game!
                    </p>
                    <p>
                        If you aren't sure how overlays work already, I recommend you read my previous post, which you can find here: <br><a href="../how-do-cheat-overlays-work/">How do Cheat Overlays Work?</a>. It explains the concepts behind how overlays work and how to setup your environment for this project.
                    </p>
                    <p><strong>Please hover over any words highlighted in purple to get a description of what they mean!</strong></p>
                  
                <h2>Code Structure</h2>
                    <p>Our code will follow a structure similar to this:</p>
                    <img src="../../images/OverlayCodeFlow.png">

                <h2>DWM: What is it and how do we check for it?</h2>
                    <p>DWM (Desktop Window Manager) is a Windows service that renders the GUI for windows. It does this through drawing to an off-screen surface within video memory. Then renders the image onto the display.</p>
                    <p>DWM enables us to be able to create our transparent window seamlessly.</p>

                    <p><strong>How do we check for DWM?</strong></p>
                    <p>There is a function available to us to check for DWM, that being <code>DWMIsCompositionEnabled()</code></p>

                    <p><strong>Code:</strong></p>
                    <pre><code>
void checkDWM()
{
  BOOL isEnabled;
  HRESULT hr = DWMIsCompositionEnabled(&isEnabled);
  if (!isEnabled)
  {
    printf("DWM is not enabled on your machine...");
  }
}
                    </code></pre>

                <h2>Gathering game window information</h2>
                    <p>
                      In order to gather information on our games screen, we need to first find the screen, and return the handle from it.<br>
                      If we were successful in finding a handle, we can then grab the process ID for the window which we can then use to obtain the games process handle.
                    </p>

                    <p>Next, we're going to gather information regarding the dimensions of the screen. We can do this by utilizing <code>GetWindowRect()</code>.</p>
                    <p>We can then set some other variables during this time based off the dimensions such as our overlays width and height.</p>

                    <p>Lastly, we can call <code>MoveWindow()</code>, which will move our overlay window to the same position as our games window based on the variables we gathered earlier.</p>
                    <p>We'll also want to go ahead and define a place that we can store all the values we're gathering so that we can use them in later functions.</p>
                    <p><strong>Code:</strong></p>
                    <pre><code>
struct WindowInfo
{
  HWND gameWindowHandle;
  DWORD gameWindowProcID;
  RECT rect;
  MARGINS margin;
}

struct OverlayInfo
{
  int width;
  int height;
}

HANDLE gameHandle;

void getGameWindowInfo()
{
  windowInfo.gameWindowHandle = FindWindowA(0, "Title of game's window");

  if (windowInfo.gameWindowHandle)
  {
    GetWindowThreadProcessId(windowInfo.gameWindowHandle, &windowInfo.gameWindowProcID);
    gameHandle = OpenProcess(PROCESS_ALL_ACCESS, false, windowInfo.gameWindowProcID);
    GetWindowRect(windowInfo.gameWindowHandle, &windowInfo.rect);
    overlayInfo.width = windowInfo.rect.right - windowInfo.rect.left;
    overlayInfo.height = windowInfo.rect.bottom - windowInfo.rect.top;
    overlayInfo.margin = { 0, 0, overlayInfo.width, overlayInfo.height };

    MoveWindow(overlayInfo.overlayWindowHandle, windowInfo.rect.left, windowInfo.rect.top, overlayInfo.width, overlayInfo.height, true);
  }
}
                    </code></pre>
                
                <h2>Creating a window class</h2>
                    <p>
                      In order to use the function <code>CreateWindowEx</code>, we first have to register a class that we will use to set some parameters for our Window.<br>
                      There are too many parameters to explain here, I highly recommend you check out the MSDN for the structure which can be found here: <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassexa">WNDCLASSEXA structure</a>
                    </p>
                    <p>After setting the class structure, along with a winproc function to handle the windows functionality. We can then register the class!</p>
                    <p>As well we'll include updates to our previous structures</p>

                    <p><strong>Code:</strong></p>
                    <pre><code>
struct WindowInfo
{
  HWND gameWindowHandle;
  DWORD gameWindowProcID;
  RECT rect;
}

struct OverlayInfo
{
  WNDCLASSEXA class;
  char name[256];
  int width;
  int height;
}

LRESULT CALLBACK WinProcedure(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_PAINT:
        direct3D9XRender();
        break;

    case WM_DESTROY:
        PostQuitMessage(1);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
        break;
    }
    return 0;
}

void createClass(WNDPROC winproc, char* windowName, HINSTANCE hInstance)
{
  sprintf_s(overlayInfo.name, "%s", windowName);
  overlayInfo.class.cbClsExtra = 0;
	overlayInfo.class.cbSize = sizeof(WNDCLASSEXA);
	overlayInfo.class.cbWndExtra = 0;
	overlayInfo.class.hbrBackground = (HBRUSH)CreateSolidBrush(RGB(0, 0, 0));
	overlayInfo.class.hCursor = LoadCursor(0, IDC_ARROW);
	overlayInfo.class.hIcon = LoadIcon(0, IDI_APPLICATION);
	overlayInfo.class.hIconSm = LoadIcon(0, IDI_APPLICATION);
	overlayInfo.class.hInstance = hInstance;
	overlayInfo.class.lpfnWndProc = winproc;
	overlayInfo.class.lpszClassName = overlayInfo.name; // May cause issues
	overlayInfo.class.lpszMenuName = nullptr;           // May cause issues
	overlayInfo.class.style = CS_HREDRAW | CS_VREDRAW;

  if (!RegisterClassExA(&overlayInfo.class))
  {
    exit(1);
  }
}
                    </code></pre>
                    <p><strong>Depending on how you setup your project you can retrieve hInstance in a variety of ways.</strong> Since I was injecting a DLL that would then create the external overlay, I retrieved hInstance from the DLL attach process.</p>
                
                <h2>Create and show the overlay</h2>
                    <p>
                      Now that we have registered our class, we can create our overlay window as well as show it overtop the games window. As we mentioned earlier, 
                      since we've already identified that DWM is working on our machine, we can utilize <code>DwmExtendFrameIntoClientArea()</code>.
                    </p>
                    <p>As well, during this process we will set attributes for the window such as our Alpha value. That way we can have a transparent overlay, or a solid one if you'd prefer!</p>
                    <p><strong>Code:</strong></p>
                    <pre><code>
void createAndShowOverlay(HINSTANCE hInstance)
{
  overlayInfo.overlayWindowHandle = createWindowExA(WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TRANSPARENT, overlayInfo.name, "My overlay", WS_POPUP, 1, 1, overlayInfo.width, overlayInfo.height, 0, 0, hInstance, 0);
  SetLayeredWindowAttributes(overlayInfo.overlayWindowHandle, RGB(0, 0, 0), 122, LWA_COLORKEY | LWA_ALPHA);
  ShowWindow(overlayInfo.overlayWindowHandle, SW_SHOW);
  DwmExtendFrameIntoClientArea(overlayInfo.overlayWindowHandle, &overlayInfo.margin);
}
                    </code></pre>
                    <p><code>createWindowExA()</code> is a finicky function and it will either work perfectly or it will fail and tell you that it failed to create. You can utilize <code>GetLastError()</code> to check the error code that it is returning.</p>
                    <p>During my time creating this program, I ran into issues with the lpClassName and lpWindowName. I recommend debugging your program when you run it and place breakpoints of those lines of code to see what may be causing issues.</p>

                <h2>Initializing DirectX</h2>
                    <p>Before we are able to start rendering to our screen, we first need to initialize out DirectX so that we can interact with our GPU to render.</p>
                    <p>To do this we'll create an <code>IDirect3D9EX</code> interface. Then we will intialize our <code>D3DPRESENT_PARAMETERS</code> structure and set it's parameters to meet how our overlay will be setup.</p>
                    <p>Finally, we will create our device which will interact with the GPU along with any other additional interfaces we need such as <code>ID3DXLine</code> so that we can draw on our overlay window.</p>
                    <p><strong>Code:</strong></p>
                    <pre><code>
IDirect3D9Ex* m_pObject;
IDirect3DDevice9Ex* m_pDevice;
D3DPRESENT_PARAMETERS m_D3DParam;
ID3DXLine* m_pLine;

void Direct3D9XInit(HWND hwnd)
{
	hr = Direct3DCreate9Ex(D3D_SDK_VERSION, &m_pObject);     // Creates an IDirect3D9Ex interface to create Direct 3D 9Ex objects

	ZeroMemory(&m_D3DParam, sizeof(m_D3DParam));             // Initializes our D3DPRESENT_PARAMETERS with all zeros

	m_D3DParam.Windowed = true;                              // If application (our game) runs windowed
	m_D3DParam.BackBufferFormat = D3DFMT_A8R8G8B8;           // Defines how color or depth information is stored
	m_D3DParam.BackBufferWidth = overlayInfo.width;          // Width of the new swap chain's back buffer in pixels (Our overlay's width)
	m_D3DParam.BackBufferHeight = overlayInfo.height;        // Height of the new swap chain's back buffer in pixels (Our overlay's height)
	m_D3DParam.EnableAutoDepthStencil = true;                // Makes Direct3D manage depth buffers for the application
	m_D3DParam.AutoDepthStencilFormat = D3DFMT_D16;          // The format of the automatic depth-stencil surface the device will create
	m_D3DParam.SwapEffect = D3DSWAPEFFECT_DISCARD;           // When rendering, this makes it present the back buffer, then discard it

	// Creates a device to represent the display adapter
	hr = m_pObject->CreateDeviceEx(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hwnd, D3DCREATE_HARDWARE_VERTEXPROCESSING, &m_D3DParam, 0, &m_pDevice);

	if (m_pLine == nullptr)
	{
                    // Creates the interfact to implment line drawing
		D3DXCreateLine(m_pDevice, &m_pLine);
	}
}
                    </code></pre>

                <h2>Rendering with DirectX</h2>
                    <p>As I mentioned in the concepts article, when we are rendering with Direct3D, we have to include everything we want to render within <code>BeginScene()</code> and <code>EndScene()</code>.</p>
                    <p>For my overlay, my main focus was to make something that works, and then to make it pretty and conventional afterwards.</p>
                    <p>With that in mind, my focus for creating my first iteration of the overlay was to have a way to make the overlay appear and disapeer. As well as create a tiny box that would be able to hold information once I created a font interface to write text.</p>
                    <p><strong>Code:</strong></p>
                    <pre><code>
void direct3D9XRender()
{
  m_pDevice->BeginScene();
  if (GetForegroundWindow() == windowInfo.gameWindowHandle) // Compares current focused window to the window that we specified in FindWindowA()
  {
    		if (GetAsyncKeyState(VK_INSERT) & 1)
		{
			bMenuEnabled = !bMenuEnabled;
		}

		if (bMenuEnabled)
		{
			RECT pos;
			pos.right = 900;  // Position away from the right
			pos.bottom = 900; // Position away from the bottom

			pos.left = 20;     // Position away from the left
			pos.top = 20;      // Position away from the top

			// Black Background of border
			draw::filledRect(18, 20, 250, 120, D3DCOLOR_ARGB(5, 0, 255, 0), m_pLine);
			// Outer rect for border
			draw::borderedRect(17, 19, 250, 120, 1, 1, 1, 1, D3DCOLOR_ARGB(255, 255, 255, 255), m_pLine);
			// White title rect
			draw::filledRect(17, 19, 250, 19, D3DCOLOR_ARGB(255, 255, 255, 255), m_pLine);
		}
	}
	m_pDevice->EndScene();
	m_pDevice->PresentEx(0, 0, 0, 0, 0);
	m_pDevice->Clear(0, 0, D3DCLEAR_TARGET, 0, 1.0f, 0);
}
                    </code></pre>

                    <p>Deciding what and how to draw can be a little complicated and a bit outside of the scope of this post. I will include a link at the bottom to the MSDN that speaks on how drawing works in Direct3D.</p>
                    <p>As well you can notice at the bottom we have to call <code>PresentEx()</code> and <code>Clear()</code>. Which are responsible for presenting our rendered screen as well as clearing one or more surfaces, respectively. </p>


                <h2>Main code loop</h2>
                    <p>That was a lot of code! Hopefully most of it made sense. Luckily we are at the end and can finally call all the functions we setup.</p>
                    <p>We will call all our check and initializing functions and then run a while true loop that will continuously run <code>getGameWindowInfo()</code> so that we can continue to move our overlay on top of our screen regardless if we decide to move the game screen's position on our monitor.</p>

                    <p><strong>Code:</strong></p>
                    <pre><code>
int main() {
  checkDWM();
  getGameWindowInfo();
  createClass(WinProc, (char*)"My overlay", hInstance);
  createAndShowOverlay(hInstance);
  direct3D9XInit(overlayInfo.overlayWindowHandle);

  while (true)
  {
    getGameWindowInfo();
    if (GetAsyncKeyState(VK_END) & 1)
    {
      break;
    }
    Sleep(1);
  }

  return 0;
}

                    </code></pre>

                <h2>Conclusion</h2>
                    <p>It was very cool to be able to finally create my own overlay for a cheat. It's something that I've always struggled with in the past and had a hard time grasping exactly how <span class="hover-word">graphic API</span>'s work and how we can use them to draw overtop the game window.</p>
                    <p>Now that I have a better understanding of how we utilize creating a new window that overlaps our game window, then we interact directly with our GPU to render graphics onto the transparent screen. We are able to create an overlay that depending on how you implment it, gives us the ability to display information from the game.</p>
                    <p>I hope you were able to learn something from this post! It's my first time trying to explain how code works and I'm not sure how it came across so please feel free to let me know of anything I could improve!</p>
                    <p>Next week I will be starting to look more into Anti-Cheat and the techniques utilizied to detect and prevent cheating.</p>
                    <br>
                    <p>Please take care, take some time to learn something new, and happy game hacking!</p>
                    <p>NitoTech</p>


                <h2>Additional Resources:</h2>
                    <p>Documentation:</p>
                    <a href="https://learn.microsoft.com/en-us/windows/win32/direct3d9/primitives">MSDN - Primitives (Direct3D 9 Graphics)</a>
                    <br>
                    <a href="https://learn.microsoft.com/en-us/windows/win32/direct3d9/line-drawing-support-in-d3dx">MSDN - Line Drawing Support in D3DX (Direct3D 9)</a>

                    <p>Videos:</p>
                    <a href="https://www.youtube.com/watch?v=i8Cn7fydNUA">Guided Hacking - Skyrim Overlay Example</a>
                    <br>
                    <a href="https://www.youtube.com/watch?v=BIZyxja3Qls">CasualGamer - External Overlay in C++</a>
            </div>
        </div>
    </body>
</html>